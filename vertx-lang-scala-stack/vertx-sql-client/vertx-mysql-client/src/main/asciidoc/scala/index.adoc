= Reactive MySQL Client

The Reactive MySQL Client is a client for MySQL with a straightforward API focusing on
scalability and low overhead.

*Features*

* Event driven
* Lightweight
* Built-in connection pooling
* Prepared queries caching
* Cursor support
* Row streaming
* RxJava 1 and RxJava 2
* Direct memory to object without unnecessary copies
* Java 8 Date and Time
* MySQL utilities commands support

== Usage

To use the Reactive MySQL Client add the following dependency to the _dependencies_ section of your build descriptor:

* Maven (in your `pom.xml`):

[source,xml]
----
<dependency>
 <groupId>${maven.groupId}</groupId>
 <artifactId>${maven.artifactId}</artifactId>
 <version>${maven.version}</version>
</dependency>
----
* Gradle (in your `build.gradle` file):

[source,groovy]
----
dependencies {
 compile '${maven.groupId}:${maven.artifactId}:${maven.version}'
}
----

== Getting started

Here is the simplest way to connect, query and disconnect

[source,scala]
----

// Connect options
var connectOptions = MySQLConnectOptions()
  .setPort(3306)
  .setHost("the-host")
  .setDatabase("the-db")
  .setUser("user")
  .setPassword("secret")


// Pool options
var poolOptions = PoolOptions()
  .setMaxSize(5)


// Create the client pool
var client = MySQLPool.pool(connectOptions, poolOptions)

// A simple query
client.queryFuture("SELECT * FROM users WHERE id='julien'").onComplete{
  case Success(result) => println("Success")
  case Failure(cause) => println("Failure")
}

----

== Connecting to MySQL

Most of the time you will use a pool to connect to MySQL:

[source,scala]
----

// Connect options
var connectOptions = MySQLConnectOptions()
  .setPort(3306)
  .setHost("the-host")
  .setDatabase("the-db")
  .setUser("user")
  .setPassword("secret")


// Pool options
var poolOptions = PoolOptions()
  .setMaxSize(5)


// Create the pooled client
var client = MySQLPool.pool(connectOptions, poolOptions)

----

The pooled client uses a connection pool and any operation will borrow a connection from the pool
to execute the operation and release it to the pool.

If you are running with Vert.x you can pass it your Vertx instance:

[source,scala]
----

// Connect options
var connectOptions = MySQLConnectOptions()
  .setPort(3306)
  .setHost("the-host")
  .setDatabase("the-db")
  .setUser("user")
  .setPassword("secret")


// Pool options
var poolOptions = PoolOptions()
  .setMaxSize(5)

// Create the pooled client
var client = MySQLPool.pool(vertx, connectOptions, poolOptions)

----

You need to release the pool when you don't need it anymore:

[source,scala]
----

// Close the pool and all the associated resources
pool.close()

----

When you need to execute several operations on the same connection, you need to use a client
`link:../../scaladocs/io/vertx/scala/mysqlclient/MySQLConnection.html[connection]`.

You can easily get one from the pool:

[source,scala]
----

// Connect options
var connectOptions = MySQLConnectOptions()
  .setPort(3306)
  .setHost("the-host")
  .setDatabase("the-db")
  .setUser("user")
  .setPassword("secret")


// Pool options
var poolOptions = PoolOptions()
  .setMaxSize(5)


// Create the pooled client
var client = MySQLPool.pool(vertx, connectOptions, poolOptions)

// Get a connection from the pool
client.getConnectionFuture().onComplete{
  case Success(result) => {

    println("Connected")

    // Obtain our connection
    var conn = result

    // All operations execute on the same connection
    conn.queryFuture("SELECT * FROM users WHERE id='julien'").onComplete{
      case Success(result) => {
        conn.queryFuture("SELECT * FROM users WHERE id='emad'").onComplete{
          case Success(result) => println("Success")
          case Failure(cause) => println("Failure")
        }
      }
      case Failure(cause) => {
        println(s"$cause")
      }
    }
  }
  case Failure(cause) => {
    println(s"$cause")
  }
}

----

Once you are done with the connection you must close it to release it to the pool, so it can be reused.

== Configuration

There are several alternatives for you to configure the client.

=== data object

A simple way to configure the client is to specify a `MySQLConnectOptions` data object.

[source,scala]
----

// Data object
var connectOptions = MySQLConnectOptions()
  .setPort(3306)
  .setHost("the-host")
  .setDatabase("the-db")
  .setUser("user")
  .setPassword("secret")


// Pool Options
var poolOptions = PoolOptions()
  .setMaxSize(5)


// Create the pool from the data object
var pool = MySQLPool.pool(vertx, connectOptions, poolOptions)

pool.getConnectionFuture().onComplete{
  case Success(result) => println("Success")
  case Failure(cause) => println("Failure")
}

----

=== connection uri

Apart from configuring with a `MySQLConnectOptions` data object, We also provide you an alternative way to connect when you want to configure with a connection URI:

[source,scala]
----

// Connection URI
var connectionUri = "mysql://dbuser:secretpassword@database.server.com:3211/mydb"

// Create the pool from the connection URI
var pool = MySQLPool.pool(connectionUri)

// Create the connection from the connection URI
MySQLConnection.connect(vertx, connectionUri, {
  case Success(result) => println("Success")
  case Failure(cause) => println("Failure")
})

----

More information about connection string formats can be found in the https://dev.mysql.com/doc/refman/8.0/en/connecting-using-uri-or-key-value-pairs.html#connecting-using-uri[MySQL Reference].

Currently the client supports the following parameter key words in connection uri

* host
* port
* user
* password
* schema
* socket

include::queries.adoc[]

include::connections.adoc[]

include::cursor.adoc[]

== MySQL type mapping

Currently the client supports the following MySQL types

* BOOL,BOOLEAN (`java.lang.Byte`)
* TINYINT (`java.lang.Byte`)
* SMALLINT (`java.lang.Short`)
* MEDIUMINT (`java.lang.Integer`)
* INT,INTEGER (`java.lang.Integer`)
* BIGINT (`java.lang.Long`)
* FLOAT (`java.lang.Float`)
* DOUBLE (`java.lang.Double`)
* NUMERIC (`io.vertx.sqlclient.data.Numeric`)
* DATE (`java.time.LocalDate`)
* DATETIME (`java.time.LocalDateTime`)
* TIME (`java.time.Duration`)
* TIMESTAMP (`java.time.LocalDateTime`)
* YEAR (`java.lang.Short`)
* CHAR (`java.lang.String`)
* VARCHAR (`java.lang.String`)
* BINARY (`io.vertx.core.buffer.Buffer`)
* VARBINARY (`io.vertx.core.buffer.Buffer`)
* TINYBLOB (`io.vertx.core.buffer.Buffer`)
* TINYTEXT (`java.lang.String`)
* BLOB (`io.vertx.core.buffer.Buffer`)
* TEXT (`java.lang.String`)
* MEDIUMBLOB (`io.vertx.core.buffer.Buffer`)
* MEDIUMTEXT (`java.lang.String`)
* LONGBLOB (`io.vertx.core.buffer.Buffer`)
* LONGTEXT (`java.lang.String`)

Tuple decoding uses the above types when storing values

=== Handling BOOLEAN

In MySQL `BOOLEAN` and `BOOL` data types are synonyms for `TINYINT(1)`. A value of zero is considered false, non-zero values are considered true.
A `BOOLEAN` data type value is stored in `Row` or `Tuple` as `java.lang.Byte` type, you can call `Row#getValue` to retrieve it as a `java.lang.Byte` value,
or you can call `Row#getBoolean` to retrieve it as `java.lang.Boolean` value.

[source,scala]
----
client.queryFuture("SELECT graduated FROM students WHERE id = 0").onComplete{
  case Success(result) => {
    var rowSet = result
    rowSet.foreach(row => {
      var pos = row.getColumnIndex("graduated")
      var value = row.get(java.lang.Byte.class, pos)
      var graduated = row.getBoolean("graduated")
    })

  }
  case Failure(cause) => {
    println(s"$cause")
  }
}

----

When you want to execute a prepared statement with a param of a `BOOLEAN` value, you can simply add the `java.lang.Boolean` value to the params list.

[source,scala]
----
client.preparedQueryFuture("UPDATE students SET graduated = ? WHERE id = 0", Tuple.of(true)).onComplete{
  case Success(result) => {
    println("Updated with the boolean value")
  }
  case Failure(cause) => {
    println(s"$cause")
  }
}

----

=== Handling NUMERIC

The `Numeric` Java type is used to represent the MySQL `NUMERIC` type.

[source,scala]
----
var numeric = row.get(io.vertx.sqlclient.data.Numeric.class, 0)
if (numeric.isNaN()) {
  // Handle NaN
} else {
  var value = numeric.bigDecimalValue()
}

----

== Collector queries

You can use Java collectors with the query API:

[source,scala]
----
Code not translatable
----

The collector processing must not keep a reference on the `link:../../scaladocs/io/vertx/scala/sqlclient/Row.html[Row]` as
there is a single row used for processing the entire set.

The Java `Collectors` provides many interesting predefined collectors, for example you can
create easily create a string directly from the row set:

[source,scala]
----
Code not translatable
----

== MySQL utility command

Sometimes you want to use MySQL utility commands and we provide support for this.
More information can be found in the https://dev.mysql.com/doc/dev/mysql-server/8.0.12/page_protocol_command_phase_utility.html[MySQL utility commands].

=== COM_PING

You can use `COM_PING` command to check if the server is alive. The handler will be notified if the server responds to the PING, otherwise the handler will never be called.

[source,scala]
----
connection.pingFuture().onComplete{
  case Success(result) => println("Success")
  case Failure(cause) => println("Failure")
}

----

=== COM_RESET_CONNECTION

You can reset the session state with `COM_RESET_CONNECTION` command, this will reset the connection state like:
- user variables
- temporary tables
- prepared statements

[source,scala]
----
connection.resetConnectionFuture().onComplete{
  case Success(result) => {
    println("Connection has been reset now")
  }
  case Failure(cause) => {
    println(s"$cause")
  }
}

----

=== COM_CHANGE_USER

You can change the user of the current connection, this will perform a re-authentication and reset the connection state like `COM_RESET_CONNECTION`.

[source,scala]
----
var authenticationOptions = MySQLConnectOptions()
  .setUser("newuser")
  .setPassword("newpassword")
  .setDatabase("newdatabase")

connection.changeUserFuture(authenticationOptions).onComplete{
  case Success(result) => {
    println("User of current connection has been changed.")
  }
  case Failure(cause) => {
    println(s"$cause")
  }
}

----

=== COM_INIT_DB

You can use `COM_INIT_DB` command to change the default schema of the connection.

[source,scala]
----
connection.specifySchemaFuture("newschema").onComplete{
  case Success(result) => {
    println("Default schema changed to newschema")
  }
  case Failure(cause) => {
    println(s"$cause")
  }
}

----

=== COM_STATISTICS

You can use `COM_STATISTICS` command to get a human readable string of some internal status variables in MySQL server.

[source,scala]
----
connection.getInternalStatisticsFuture().onComplete{
  case Success(result) => {
    println(s"Statistics: ${result}")
  }
  case Failure(cause) => {
    println(s"$cause")
  }
}

----

=== COM_DEBUG

You can use `COM_DEBUG` command to dump debug info to the MySQL server's STDOUT.

[source,scala]
----
connection.debugFuture().onComplete{
  case Success(result) => {
    println("Debug info dumped to server's STDOUT")
  }
  case Failure(cause) => {
    println(s"$cause")
  }
}

----

=== COM_SET_OPTION

You can use `COM_SET_OPTION` command to set options for the current connection. Currently only `CLIENT_MULTI_STATEMENTS` can be set.

For example, you can disable `CLIENT_MULTI_STATEMENTS` with this command.

[source,scala]
----
connection.setOptionFuture(MySQLSetOption.MYSQL_OPTION_MULTI_STATEMENTS_OFF).onComplete{
  case Success(result) => {
    println("CLIENT_MULTI_STATEMENTS is off now")
  }
  case Failure(cause) => {
    println(s"$cause")
  }
}

----